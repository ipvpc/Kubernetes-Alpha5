---
# Ansible Playbook: Create DevOps Kubernetes Cluster
# This playbook creates a Kubernetes cluster named "devops"
# Usage: ansible-playbook playbooks/devops-cluster.yml -i ../inventory-devops.yml

- name: Pre-installation information
  hosts: all
  become: false
  gather_facts: false
  
  vars:
    cluster_name: "devops"
  
  tasks:
    - name: Display cluster information
      debug:
        msg: |
          ==========================================
          Creating Kubernetes Cluster: {{ cluster_name }}
          Install Method: {{ install_method | default('kubeadm') }}
          ==========================================
          Control Plane Nodes: {{ groups['control_plane'] | default([]) | length }}
          Worker Nodes: {{ groups['workers'] | default([]) | length }}
          ==========================================

- import_playbook: kubeadm-install.yml
  when: install_method | default('kubeadm') == "kubeadm"

- import_playbook: k3s-install.yml
  when: install_method | default('kubeadm') == "k3s"

- name: Post-installation tasks for DevOps cluster
  hosts: control_plane[0]
  become: true
  gather_facts: false
  
  vars:
    cluster_name: "devops"
    setup_network_isolation: false
  
  tasks:
    - name: Check if admin.conf exists
      stat:
        path: /etc/kubernetes/admin.conf
      register: admin_conf_check

    - name: Check if copied kubeconfig exists
      stat:
        path: /root/.kube/config
      register: copied_kubeconfig_check

    - name: Set kubeconfig path
      set_fact:
        kubeconfig: "{{ '/etc/kubernetes/admin.conf' if admin_conf_check.stat.exists else '/root/.kube/config' }}"
      when: admin_conf_check.stat.exists or copied_kubeconfig_check.stat.exists

    - name: Check if kubeconfig exists
      stat:
        path: "{{ kubeconfig }}"
      register: kubeconfig_check
      when: admin_conf_check.stat.exists or copied_kubeconfig_check.stat.exists

    - name: Set cluster context name
      shell: |
        kubectl config --kubeconfig={{ kubeconfig }} rename-context default {{ cluster_name }} 2>/dev/null || \
        kubectl config --kubeconfig={{ kubeconfig }} set-context {{ cluster_name }} --cluster=kubernetes --user=kubernetes-admin 2>/dev/null || true
      changed_when: false
      ignore_errors: yes
      when: kubeconfig_check.stat.exists

    - name: Verify cluster is ready
      shell: kubectl --kubeconfig={{ kubeconfig }} get nodes -o wide
      register: cluster_status
      changed_when: false
      ignore_errors: yes
      when: kubeconfig_check.stat.exists

    - name: Display cluster status
      debug:
        msg: "{{ cluster_status.stdout_lines | default(['Cluster status check failed']) }}"
      when: cluster_status is defined

    - name: Wait for Calico to be ready before setting up network isolation
      shell: |
        kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod -l k8s-app=calico-node -n kube-system --timeout=300s
      register: calico_wait
      retries: 10
      delay: 10
      until: calico_wait.rc == 0
      changed_when: false
      ignore_errors: yes
      when: 
        - kubeconfig_check.stat.exists
        - cni_plugin | default('calico') == "calico"
        - setup_network_isolation | bool

    - name: Setup network isolation (default deny-all)
      shell: |
        cat <<EOF | kubectl --kubeconfig={{ kubeconfig }} apply -f -
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        metadata:
          name: default-deny-all
          namespace: default
        spec:
          podSelector: {}
          policyTypes:
          - Ingress
          - Egress
        EOF
      register: default_policy
      changed_when: default_policy.rc == 0
      when: 
        - kubeconfig_check.stat.exists
        - setup_network_isolation | bool
        - calico_wait is defined
        - (calico_wait.rc | default(999)) == 0

    - name: Setup allow DNS network policy
      shell: |
        kubectl --kubeconfig={{ kubeconfig }} label namespace kube-system name=kube-system --overwrite || true
        cat <<EOF | kubectl --kubeconfig={{ kubeconfig }} apply -f -
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        metadata:
          name: allow-dns
          namespace: default
        spec:
          podSelector: {}
          policyTypes:
          - Egress
          egress:
          - to:
            - namespaceSelector:
                matchLabels:
                  name: kube-system
            ports:
            - protocol: UDP
              port: 53
            - protocol: TCP
              port: 53
        EOF
      register: dns_policy
      changed_when: dns_policy.rc == 0
      when: 
        - kubeconfig_check.stat.exists
        - setup_network_isolation | bool
        - calico_wait is defined
        - (calico_wait.rc | default(999)) == 0

    - name: Display network policies created
      shell: kubectl --kubeconfig={{ kubeconfig }} get networkpolicies -A
      register: np_status
      changed_when: false
      failed_when: false
      when: 
        - kubeconfig_check.stat.exists
        - setup_network_isolation | bool

    - name: Wait for CNI to be ready before installing Traefik
      shell: |
        if kubectl --kubeconfig={{ kubeconfig }} get daemonset -n kube-system calico-node 2>/dev/null; then
          kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod -l k8s-app=calico-node -n kube-system --timeout=300s
        elif kubectl --kubeconfig={{ kubeconfig }} get daemonset -n kube-flannel kube-flannel-ds 2>/dev/null; then
          kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod -l app=flannel -n kube-flannel --timeout=300s
        else
          echo "Waiting for CNI pods to be ready..."
          sleep 30
        fi
      register: cni_ready_for_traefik
      retries: 10
      delay: 10
      until: cni_ready_for_traefik.rc == 0
      changed_when: false
      ignore_errors: yes
      when: kubeconfig_check.stat.exists

    - name: Install Traefik Ingress Controller
      block:
        - name: Create Traefik namespace
          shell: |
            kubectl --kubeconfig={{ kubeconfig }} create namespace traefik --dry-run=client -o yaml | kubectl --kubeconfig={{ kubeconfig }} apply -f -
          register: traefik_ns
          changed_when: traefik_ns.rc == 0
          failed_when: false
          when: kubeconfig_check.stat.exists

        - name: Install Traefik Ingress Controller
          shell: |
            cat <<EOF | kubectl --kubeconfig={{ kubeconfig }} apply -f -
            apiVersion: v1
            kind: Namespace
            metadata:
              name: traefik
            ---
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: traefik-ingress-controller
              namespace: traefik
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: traefik-ingress-controller
            rules:
            - apiGroups:
              - ""
              resources:
              - services
              - endpoints
              - secrets
              verbs:
              - get
              - list
              - watch
            - apiGroups:
              - networking.k8s.io
              resources:
              - ingresses
              verbs:
              - get
              - list
              - watch
            - apiGroups:
              - networking.k8s.io
              resources:
              - ingresses/status
              verbs:
              - update
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: traefik-ingress-controller
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: traefik-ingress-controller
            subjects:
            - kind: ServiceAccount
              name: traefik-ingress-controller
              namespace: traefik
            ---
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: traefik
              namespace: traefik
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: traefik
              template:
                metadata:
                  labels:
                    app: traefik
                spec:
                  serviceAccountName: traefik-ingress-controller
                  containers:
                  - name: traefik
                    image: traefik:v2.10
                    args:
                    - --api.insecure=true
                    - --providers.kubernetesingress=true
                    - --entrypoints.web.address=:80
                    - --entrypoints.websecure.address=:443
                    ports:
                    - name: web
                      containerPort: 80
                    - name: websecure
                      containerPort: 443
                    - name: admin
                      containerPort: 8080
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: traefik
              namespace: traefik
            spec:
              type: NodePort
              selector:
                app: traefik
              ports:
              - name: web
                port: 80
                targetPort: 80
                nodePort: 30080
              - name: websecure
                port: 443
                targetPort: 443
                nodePort: 30443
              - name: admin
                port: 8080
                targetPort: 8080
                nodePort: 30880
            EOF
          register: traefik_install
          retries: 3
          delay: 10
          until: traefik_install.rc == 0
          changed_when: traefik_install.rc == 0
          failed_when: false
          ignore_errors: yes
          when: kubeconfig_check.stat.exists

        - name: Wait for Traefik to be ready
          shell: |
            kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod -l app=traefik -n traefik --timeout=300s
          register: traefik_wait
          retries: 10
          delay: 10
          until: traefik_wait.rc == 0
          changed_when: false
          ignore_errors: yes
          when: kubeconfig_check.stat.exists

        - name: Create Traefik IngressClass
          shell: |
            cat <<EOF | kubectl --kubeconfig={{ kubeconfig }} apply -f -
            apiVersion: networking.k8s.io/v1
            kind: IngressClass
            metadata:
              name: traefik
            spec:
              controller: traefik.io/ingress-controller
            EOF
          register: traefik_ingressclass
          changed_when: traefik_ingressclass.rc == 0
          failed_when: false
          when: kubeconfig_check.stat.exists

        - name: Check Traefik status
          shell: kubectl --kubeconfig={{ kubeconfig }} get pods,svc -n traefik
          register: traefik_status
          changed_when: false
          failed_when: false
          when: kubeconfig_check.stat.exists

        - name: Display Traefik status
          debug:
            msg: "{{ traefik_status.stdout_lines }}"
          when: traefik_status is defined

      when: kubeconfig_check.stat.exists

    - name: Display cluster information
      debug:
        msg: |
          ==========================================
          DevOps Kubernetes Cluster Created!
          Cluster Name: {{ cluster_name }}
          CNI Plugin: {{ cni_plugin | default('calico') }}
          Network Isolation: {{ 'Enabled' if setup_network_isolation else 'Disabled' }}
          Ingress Controller: Traefik
          ==========================================
          To access the cluster:
          1. Copy kubeconfig from master node:
             scp {{ ansible_user | default('root') }}@{{ hostvars[groups['control_plane'][0]]['ansible_host'] }}:/root/.kube/config ~/.kube/config-{{ cluster_name }}
          2. Set KUBECONFIG:
             export KUBECONFIG=~/.kube/config-{{ cluster_name }}
          3. Verify cluster:
             kubectl get nodes
          
          Traefik Ingress Controller:
          - HTTP: http://{{ hostvars[groups['control_plane'][0]]['ansible_host'] }}:30080
          - HTTPS: https://{{ hostvars[groups['control_plane'][0]]['ansible_host'] }}:30443
          - Dashboard: http://{{ hostvars[groups['control_plane'][0]]['ansible_host'] }}:30880
          - Status: {{ 'Ready' if (traefik_wait is defined and (traefik_wait.rc | default(999)) == 0) else 'Check manually' }}
          
          {% if setup_network_isolation %}
          
          Network Isolation:
          - Default deny-all policy is active
          - DNS is allowed
          - Pods are isolated by default
          - To expose services, use NodePort/LoadBalancer/Ingress
          - See: ansible/NETWORK_ISOLATION_GUIDE.md
          {% endif %}
          
          To create an ingress:
          kubectl apply -f - <<EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: example-ingress
            annotations:
              traefik.ingress.kubernetes.io/rule-type: PathPrefix
          spec:
            ingressClassName: traefik
            rules:
            - host: example.local
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: your-service
                      port:
                        number: 80
          EOF
          ==========================================

